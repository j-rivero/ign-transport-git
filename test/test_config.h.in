/*
 * Copyright (C) 2014 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

#ifndef __IGN_TRANSPORT_TEST_CONFIG_HH__INCLUDED__
#define __IGN_TRANSPORT_TEST_CONFIG_HH__INCLUDED__

#define PROJECT_SOURCE_PATH "${PROJECT_SOURCE_DIR}"
#define PROJECT_BINARY_PATH "${PROJECT_BINARY_DIR}"

#ifdef _WIN32
  #include <filesystem>
#else
  #include <signal.h>
#endif

//////////////////////////////////////////////////
/*
 * setenv/unstenv are not present in Windows. Define them to make the code
 * portable
 */
#if (_MSC_VER >= 1400) // Visual Studio 2005
#include <sstream>

int setenv(const char * name, const char * value, int /*rewrite*/)
{
  std::stringstream sstr;
  sstr << *name << '=' << *value;
  return _putenv(sstr.str().c_str());
}

//////////////////////////////////////////////////
void unsetenv(const char * name)
{
  std::stringstream sstr;
  sstr << *name << '=';
  _putenv(sstr.str().c_str());
}
#endif

namespace testing
{
   //////////////////////////////////////////////////
   ///
   /// \brief Join str1 and str2 considering both as storing system paths
   /// \param[in] str1 string containing a path
   /// \param[in] str2 string containing a path
   std::string portablePathUnion(const std::string str1, const std::string str2)
   {
#ifdef _WIN32
        std::tr2::sys::path base_path(str1);
        return base_path /= str2;
#else
        // Ugly as hell but trying to avoid boost::filesystem
        return str1 + "/" + str2;
#endif
   }

#ifdef _WIN32
   typedef PROCESS_INFORMATION fork_handler_t;
#else
   typedef pid_t fork_handler_t;
#endif


   //////////////////////////////////////////////////
   ///
   /// \brief create a new process and run command on it
   /// This function is implementing the creation of a new process on both
   /// Linux (fork) and Windows (CreateProcess) and the execution of the
   /// command provided
   ///
   /// \param[in] command the full system path to the binary to run into the
   ///            new process
   fork_handler_t forkAndRun(const char * command)
   {
#ifdef _WIN32
      STARTUPINFO info={sizeof(info)};
      PROCESS_INFORMATION processInfo;

      if (! CreateProcess(NULL, const_cast<LPSTR>(command), NULL, NULL, TRUE,
		          0, NULL, NULL, &info, &processInfo))
      {
        std::cerr << "CreateProcess call failed" << std::endl;
      }

      return processInfo;
#else
      pid_t pid = fork();

      if (pid == 0)
      {
        if (execl(command, command, (char *)0) == -1)
          std::cerr << "Error running execl call: " << command << std::endl;
      }

      return pid;
#endif
   }

   //////////////////////////////////////////////////
   ///
   /// \brief wait for the end of a process and handle the termination
   /// \param[in] pi process handler of the process to wait for
   /// (PROCESS_INFORMATION in windows or fork_handler_t in UNIX)
   void waitAndCleanupFork(const fork_handler_t pi)
   {
#ifdef _WIN32
     // Wait until child process exits.
     WaitForSingleObject( pi.hProcess, INFINITE );

     // Close process and thread handles.
     CloseHandle( pi.hProcess );
     CloseHandle( pi.hThread );
#else
    // Wait for the child process to return.
    int status;
    waitpid(pi, &status, 0);
    if (status == -1)
      std::cerr << "Error while running waitpid" << std::endl;
#endif
   }

   //////////////////////////////////////////////////
   ///
   /// \brief send a termination signal to the process handled by pi
   /// \param[in] pi process handler of the process to stop
   /// (PROCESS_INFORMATION in windows or fork_handler_t in UNIX)
   void killFork(const fork_handler_t pi)
   {
#ifdef _WIN32
     // TerminateProcess return 0 on error
     if (TerminateProcess(pi.hProcess, 0) == 0)
       std::cerr << "Error running TerminateProcess: " << GetLastError();
#else
     kill(pi, SIGTERM);
#endif
   }
}

#endif  // header guard
